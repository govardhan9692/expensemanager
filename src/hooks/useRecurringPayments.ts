import { useEffect, useCallback, useRef } from 'react';
import { db } from '@/lib/firebase';
import { collection, query, getDocs, doc, writeBatch, serverTimestamp, Timestamp, arrayUnion } from 'firebase/firestore';
import { Client } from '@/types/client';
import { toast } from '@/hooks/use-toast';
import dayjs from 'dayjs';
import { v4 as uuidv4 } from 'uuid';

export const useRecurringPayments = (businessId: string | undefined, userId: string | undefined) => {
  const checkIntervalRef = useRef<NodeJS.Timeout>();

  const checkAndGenerateRecurringPayments = useCallback(async () => {
    if (!businessId || !userId) return;

    try {
      const clientsRef = collection(db, `businesses/${businessId}/clients`);
      const clientsSnapshot = await getDocs(query(clientsRef));

      const batch = writeBatch(db);
      let paymentsGenerated = 0;

      for (const clientDoc of clientsSnapshot.docs) {
        const client = clientDoc.data() as Client;
        
        for (let serviceIndex = 0; serviceIndex < client.services.length; serviceIndex++) {
          const service = client.services[serviceIndex];
          
          // Skip if not recurring or auto-generate disabled or paused
          if (
            service.paymentTerms !== 'recurring' || 
            !service.recurring?.autoGenerate ||
            service.recurring?.isPaused
          ) {
            continue;
          }

          const recurring = service.recurring;
          const now = dayjs();

          // Check if service has ended
          if (recurring.endDate && dayjs(recurring.endDate).isBefore(now)) {
            console.log(`Service ${service.serviceName} has ended. Stopping generation.`);
            
            // Mark service as completed
            const updatedServices = [...client.services];
            updatedServices[serviceIndex] = {
              ...updatedServices[serviceIndex],
              recurring: {
                ...updatedServices[serviceIndex].recurring!,
                autoGenerate: false,
              },
            };

            batch.update(doc(db, `businesses/${businessId}/clients/${clientDoc.id}`), {
              services: updatedServices,
            });

            // Create notification about service ending
            const notificationRef = doc(collection(db, `users/${userId}/inbox`));
            batch.set(notificationRef, {
              type: 'recurring_service_ended',
              from: { system: true },
              businessId: businessId,
              clientId: clientDoc.id,
              clientName: client.basicInfo.name,
              serviceId: service.serviceId,
              serviceName: service.serviceName,
              endDate: recurring.endDate,
              totalGenerated: recurring.totalGenerated || 0,
              message: `Recurring service "${service.serviceName}" for ${client.basicInfo.name} has ended as scheduled`,
              status: 'unread',
              createdAt: serverTimestamp(),
              read: false,
            });

            continue;
          }

          // Count how many future payments exist
          const futurePayments = (service.paymentSchedule || []).filter(p => {
            const isPending = p.status === 'pending' || p.status === 'scheduled';
            const isFuture = dayjs(p.dueDate).isAfter(now);
            return isPending && isFuture;
          });

          const generateAhead = recurring.generateAheadCount || 3;
          const neededPayments = generateAhead - futurePayments.length;

          if (neededPayments > 0) {
            // Find the last payment date
            let lastPaymentDate = recurring.lastGenerated 
              ? dayjs(recurring.lastGenerated) 
              : dayjs(recurring.startDate);

            // If there are existing payments, start from the last one
            if (futurePayments.length > 0) {
              const sortedPayments = futurePayments.sort((a, b) => 
                dayjs(b.dueDate).diff(dayjs(a.dueDate))
              );
              lastPaymentDate = dayjs(sortedPayments[0].dueDate);
            }

            // Generate needed number of payments
            const newPayments = [];
            for (let i = 0; i < neededPayments; i++) {
              const nextDate = calculateNextDueDate(
                lastPaymentDate,
                recurring.frequency,
                recurring.dayOfPayment,
                recurring.customDays
              );

              const newPayment = {
                scheduleId: uuidv4(),
                dueDate: nextDate.toISOString(),
                amount: service.expectedAmount,
                status: nextDate.isBefore(now.add(1, 'day')) ? 'pending' : 'scheduled',
                autoGenerated: true,
                generatedAt: now.toISOString(),
                frequency: recurring.frequency,
                periodLabel: formatPeriodLabel(nextDate, recurring.frequency),
              };

              newPayments.push(newPayment);
              lastPaymentDate = nextDate;
            }

            // Update client document with new payments
            const updatedServices = [...client.services];
            updatedServices[serviceIndex] = {
              ...updatedServices[serviceIndex],
              paymentSchedule: [...(service.paymentSchedule || []), ...newPayments],
              recurring: {
                ...updatedServices[serviceIndex].recurring!,
                lastGenerated: now.toISOString(),
                nextDueDate: lastPaymentDate.toISOString(),
                totalGenerated: (recurring.totalGenerated || 0) + neededPayments,
              },
            };

            batch.update(doc(db, `businesses/${businessId}/clients/${clientDoc.id}`), {
              services: updatedServices,
            });

            // Create notification
            if (neededPayments > 0) {
              const notificationRef = doc(collection(db, `users/${userId}/inbox`));
              batch.set(notificationRef, {
                type: 'recurring_payment_generated',
                from: { system: true },
                businessId: businessId,
                clientId: clientDoc.id,
                clientName: client.basicInfo.name,
                serviceId: service.serviceId,
                serviceName: service.serviceName,
                amount: service.expectedAmount,
                paymentsGenerated: neededPayments,
                nextDueDate: Timestamp.fromDate(lastPaymentDate.toDate()),
                message: `${neededPayments} new payment(s) generated for ${client.basicInfo.name} - ${service.serviceName}`,
                status: 'unread',
                createdAt: serverTimestamp(),
                read: false,
              });
            }

            paymentsGenerated += neededPayments;
          }
        }
      }

      if (paymentsGenerated > 0) {
        await batch.commit();
        toast({
          title: 'âœ¨ Recurring Payments Generated',
          description: `Generated ${paymentsGenerated} new payment${paymentsGenerated > 1 ? 's' : ''} for upcoming periods.`,
        });
      }
    } catch (error) {
      console.error('Error generating recurring payments:', error);
      toast({
        title: 'Error',
        description: 'Failed to generate recurring payments. Will retry shortly.',
        variant: 'destructive',
      });
    }
  }, [businessId, userId]);

  const calculateNextDueDate = (
    lastDate: dayjs.Dayjs,
    frequency: string,
    dayOfPayment: number,
    customDays?: number
  ): dayjs.Dayjs => {
    switch (frequency) {
      case 'monthly':
        const nextMonth = lastDate.add(1, 'month');
        const maxDay = nextMonth.daysInMonth();
        const targetDay = Math.min(dayOfPayment, maxDay);
        return nextMonth.date(targetDay);
      case 'weekly':
        return lastDate.add(1, 'week');
      case 'quarterly':
        const nextQuarter = lastDate.add(3, 'months');
        return nextQuarter.date(Math.min(dayOfPayment, nextQuarter.daysInMonth()));
      case 'yearly':
        return lastDate.add(1, 'year');
      case 'custom':
        return lastDate.add(customDays || 30, 'days');
      default:
        return lastDate.add(1, 'month');
    }
  };

  const formatPeriodLabel = (date: dayjs.Dayjs, frequency: string): string => {
    switch (frequency) {
      case 'monthly':
        return date.format('MMMM YYYY');
      case 'weekly':
        return `Week of ${date.format('MMM D, YYYY')}`;
      case 'quarterly':
        const quarter = Math.ceil((date.month() + 1) / 3);
        return `Q${quarter} ${date.year()}`;
      case 'yearly':
        return date.format('YYYY');
      default:
        return date.format('MMM D, YYYY');
    }
  };

  useEffect(() => {
    // Run on mount
    checkAndGenerateRecurringPayments();

    // Run every 5 minutes
    checkIntervalRef.current = setInterval(() => {
      checkAndGenerateRecurringPayments();
    }, 5 * 60 * 1000);

    return () => {
      if (checkIntervalRef.current) {
        clearInterval(checkIntervalRef.current);
      }
    };
  }, [checkAndGenerateRecurringPayments]);

  return {
    checkNow: checkAndGenerateRecurringPayments,
  };
};
